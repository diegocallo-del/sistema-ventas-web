
MANUAL DETALLADO DEL EQUIPO
SISTEMA DE VENTAS - SPRING BOOT + JAVA
7 PERSONAS

PROYECTO: Sistema de Ventas
UBICACIÓN: P:\Proyecto_Final
PAQUETE BASE: com.ventas
DURACIÓN: 8 semanas
STACK TECNOLÓGICO: Spring Boot 3.2, MySQL 8.0, Java 17

PERSONA 1: ADMINISTRADOR DE BASE DE DATOS (DBA)
NOMBRE: _______________________________ CONTACTO: ___________________
TU ROL EN EL PROYECTO
Eres el ARQUITECTO DE DATOS del proyecto. Todo lo relacionado con la estructura de la base de datos, las tablas y sus relaciones, las entidades JPA en Java y los tipos de datos constantes mediante enumeraciones. Sin ti, el proyecto no puede guardar ni recuperar información de manera estructurada.
CARPETAS DONDE TRABAJARÁS

backend/src/main/java/com/ventas/entities/ → Entidades JPA
backend/src/main/java/com/ventas/enums/ → Enumeraciones
backend/database/scripts/ → Scripts SQL
backend/database/backups/ → Respaldos
backend/database/diagramas/ → Diagramas ER

SEMANA 1: DISEÑO DE BASE DE DATOS
TAREA 1.1: Diseñar el Diagrama Entidad-Relación (ER)
Debes definir qué tablas necesita el sistema, establecer las relaciones entre ellas, definir campos de cada tabla, especificar tipos de datos e identificar claves primarias y foráneas. Las tablas sugeridas son usuarios, clientes, categorias, productos, ventas y detalle_ventas. Puedes usar herramientas como MySQL Workbench, Draw.io o Lucidchart. El archivo a entregar es database/diagramas/diagrama_er.png. Tiempo estimado: 2-3 días.
TAREA 1.2: Crear Diccionario de Datos
Documenta cada tabla explicando cada campo, definiendo restricciones y validaciones. Por ejemplo, para la tabla productos, el campo id sería de tipo INT con restricciones PRIMARY KEY y AUTO_INCREMENT, mientras que nombre sería VARCHAR de 200 caracteres con restricción NOT NULL. El archivo a entregar es database/diagramas/diccionario_datos.txt. Tiempo estimado: 1 día.
SEMANA 2: SCRIPTS SQL
TAREA 2.1: Script de Creación de Base de Datos
Crea el archivo SQL para crear la base de datos con nombre ventas_db, definiendo charset utf8mb4 y collation apropiado. Archivo: database/scripts/01_crear_base_datos.sql. Tiempo estimado: 30 minutos.
TAREA 2.2: Script de Creación de Tablas
Escribe sentencias CREATE TABLE para todas las tablas, definiendo campos, tipos de datos y restricciones. Establece relaciones usando FOREIGN KEY, define valores por defecto y agrega índices si es necesario. Es importante el orden de creación, creando primero las tablas padre. Usa ENGINE igual a InnoDB y charset utf8mb4. Archivo: database/scripts/02_crear_tablas.sql. Tiempo estimado: 1-2 días.
TAREA 2.3: Script de Datos de Prueba
Inserta al menos 1 usuario administrador, 5 a 10 categorías, 20 a 30 productos variados, 5 a 10 clientes de prueba y 3 a 5 ventas de ejemplo. Esto permite probar el sistema inmediatamente y facilita las pruebas de funcionalidad. Archivo: database/scripts/03_insertar_datos.sql. Tiempo estimado: 1 día.
SEMANA 3: ENTIDADES JPA CON SPRING BOOT
TAREA 3.1: Crear Entidades JPA
Por cada tabla, crea una clase Java anotada con JPA. Cada campo de la tabla se convierte en un atributo en la clase. A diferencia del enfoque tradicional, aquí usarás anotaciones de JPA como @Entity, @Table, @Id, @GeneratedValue, @Column, @ManyToOne, @OneToMany y @JoinColumn. También usarás Lombok con anotaciones @Data, @NoArgsConstructor, @AllArgsConstructor y @Builder para evitar escribir getters, setters y constructores manualmente.
Las entidades a crear son Usuario.java, Cliente.java, Categoria.java, Producto.java, Venta.java y DetalleVenta.java. Ubicación: backend/src/main/java/com/ventas/entities/.
Ejemplo de entidad Producto:
javapackage com.ventas.entities;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "productos")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Producto {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String nombre;
    
    @Column(columnDefinition = "TEXT")
    private String descripcion;
    
    @Column(nullable = false)
    private Double precio;
    
    @Column(nullable = false)
    private Integer stock;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "categoria_id", nullable = false)
    private Categoria categoria;
    
    @Column(nullable = false)
    private Boolean activo = true;
    
    @Column(name = "fecha_creacion", updatable = false)
    private LocalDateTime fechaCreacion;
    
    @PrePersist
    protected void onCreate() {
        fechaCreacion = LocalDateTime.now();
    }
}
Ejemplo de entidad Venta con relaciones:
java@Entity
@Table(name = "ventas")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Venta {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "cliente_id", nullable = false)
    private Cliente cliente;
    
    @ManyToOne
    @JoinColumn(name = "usuario_id", nullable = false)
    private Usuario usuario;
    
    @OneToMany(mappedBy = "venta", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<DetalleVenta> detalles = new ArrayList<>();
    
    @Column(nullable = false)
    private Double subtotal;
    
    @Column(nullable = false)
    private Double igv;
    
    @Column(nullable = false)
    private Double total;
    
    @Enumerated(EnumType.STRING)
    private TipoPago tipoPago;
    
    @Enumerated(EnumType.STRING)
    private EstadoVenta estado;
    
    private LocalDateTime fechaVenta;
    
    @PrePersist
    protected void onCreate() {
        fechaVenta = LocalDateTime.now();
        estado = EstadoVenta.COMPLETADA;
    }
}
Nota importante: Usa Long en lugar de int para los IDs, Double en lugar de double para precios, Integer en lugar de int para stock y Boolean en lugar de boolean. Esto permite valores null y es el estándar con JPA.
Tiempo estimado: 2-3 días.
TAREA 3.2: Crear Enumeraciones
Crea enumeraciones para valores fijos del sistema. Usa la anotación @Getter de Lombok para generar automáticamente los getters. Los enums a crear son TipoUsuario (ADMIN, VENDEDOR, CAJERO), EstadoVenta (PENDIENTE, COMPLETADA, CANCELADA), TipoPago (EFECTIVO, TARJETA, TRANSFERENCIA) y EstadoProducto (DISPONIBLE, AGOTADO, DESCONTINUADO). Ubicación: backend/src/main/java/com/ventas/enums/.
Ejemplo:
javapackage com.ventas.enums;

import lombok.Getter;

@Getter
public enum TipoUsuario {
    ADMIN("Administrador"),
    VENDEDOR("Vendedor"),
    CAJERO("Cajero");
    
    private final String descripcion;
    
    TipoUsuario(String descripcion) {
        this.descripcion = descripcion;
    }
}
Tiempo estimado: 1 día.
ENTREGABLES FINALES

Diagrama Entidad-Relación (imagen PNG)
Diccionario de datos (documento TXT)
Script crear base de datos
Script crear tablas
Script insertar datos de prueba
6 entidades JPA en Java con anotaciones
4 enumeraciones en Java

COORDINACIÓN CON OTROS
Trabajas de cerca con Persona 3 (Repositories) quien usará tus entidades, con Persona 6 (Coordinador) quien revisará tu diagrama ER, y con todo el equipo que usará tus entidades y enums.

PERSONA 2: DESARROLLADOR BACKEND (INFRAESTRUCTURA)
NOMBRE: _______________________________ CONTACTO: ___________________
TU ROL EN EL PROYECTO
Eres el INGENIERO DE INFRAESTRUCTURA. Te encargas de crear las clases DTO para transferencia de datos, excepciones personalizadas, configuraciones de Spring Boot, clases de utilidades y manejo de errores globales. Sin ti, cada desarrollador tendría que crear sus propias herramientas, resultando en código duplicado y desorganizado.
CARPETAS DONDE TRABAJARÁS

backend/src/main/java/com/ventas/dto/ → Data Transfer Objects
backend/src/main/java/com/ventas/exception/ → Excepciones personalizadas
backend/src/main/java/com/ventas/config/ → Configuraciones Spring
backend/src/main/java/com/ventas/util/ → Utilidades
backend/src/main/resources/ → application.properties

SEMANA 1-2: CLASES DTO (DATA TRANSFER OBJECTS)
Los DTOs son objetos que se usan para transferir datos entre el frontend y el backend, sin exponer las entidades directamente. Esto protege la estructura interna de la base de datos y permite controlar qué información se envía al cliente.
TAREA 1: Crear DTOs para todas las entidades
Crea clases DTO con Lombok usando las anotaciones @Data, @Builder, @NoArgsConstructor y @AllArgsConstructor. Las clases a crear son ProductoDTO.java, ClienteDTO.java, VentaDTO.java, DetalleVentaDTO.java, CategoriaDTO.java, UsuarioDTO.java, LoginRequest.java, LoginResponse.java y ErrorResponse.java. Ubicación: backend/src/main/java/com/ventas/dto/.
Ejemplo de ProductoDTO:
javapackage com.ventas.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductoDTO {
    private Long id;
    private String nombre;
    private String descripcion;
    private Double precio;
    private Integer stock;
    private Long categoriaId;
    private String categoriaNombre;
    private Boolean activo;
    private String fechaCreacion;
}
Ejemplo de LoginRequest y LoginResponse:
java@Data
public class LoginRequest {
    private String usuario;
    private String password;
}

@Data
@Builder
public class LoginResponse {
    private String token;
    private String tipo;
    private Long id;
    private String usuario;
    private String nombreCompleto;
    private String rol;
}
Tiempo estimado: 2-3 días.
SEMANA 2-3: EXCEPCIONES PERSONALIZADAS
TAREA 2: Crear excepciones de negocio
Crea excepciones personalizadas para manejar errores específicos del negocio. Las clases a crear son ResourceNotFoundException.java, StockInsuficienteException.java, DuplicateResourceException.java y BusinessException.java. Ubicación: backend/src/main/java/com/ventas/exception/.
Ejemplo:
javapackage com.ventas.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String resource, String field, Object value) {
        super(String.format("%s no encontrado con %s: '%s'", resource, field, value));
    }
}
TAREA 3: Crear GlobalExceptionHandler
Crea una clase anotada con @RestControllerAdvice que capture todas las excepciones del sistema y devuelva respuestas JSON con formato consistente.
javapackage com.ventas.exception;

import com.ventas.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.time.LocalDateTime;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.NOT_FOUND.value())
            .error("Not Found")
            .message(ex.getMessage())
            .build();
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(StockInsuficienteException.class)
    public ResponseEntity<ErrorResponse> handleStockInsuficiente(StockInsuficienteException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Bad Request")
            .message(ex.getMessage())
            .build();
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }
}
Tiempo estimado: 2 días.
SEMANA 3: CONFIGURACIONES DE SPRING BOOT
TAREA 4: Crear CorsConfig
Configura CORS para permitir que el frontend (que corre en puerto diferente) pueda comunicarse con el backend.
javapackage com.ventas.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                    .allowedOrigins("http://localhost:3000", "http://localhost:5173")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true);
            }
        };
    }
}
TAREA 5: Crear ModelMapperConfig
Configura ModelMapper para convertir automáticamente entre Entidades y DTOs.
javapackage com.ventas.config;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperConfig {
    
    @Bean
    public ModelMapper modelMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
            .setSkipNullEnabled(true)
            .setAmbiguityIgnored(true);
        return modelMapper;
    }
}
TAREA 6: Crear application.properties
Crea el archivo de configuración principal de Spring Boot en backend/src/main/resources/application.properties:
properties# Configuración de la aplicación
spring.application.name=Sistema de Ventas
server.port=8080

# Configuración de base de datos
spring.datasource.url=jdbc:mysql://localhost:3306/ventas_db?useSSL=false&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=

# Configuración de JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Configuración de JWT
jwt.secret=mi_clave_secreta_super_larga_y_segura_cambiar_en_produccion
jwt.expiration=86400000

# Configuración de Jackson (JSON)
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.time-zone=America/Lima
Tiempo estimado: 1-2 días.
SEMANA 4: CLASES DE UTILIDADES
TAREA 7: Crear clase Validador
javapackage com.ventas.util;

import org.apache.commons.lang3.StringUtils;
import java.util.regex.Pattern;

public class Validador {
    
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    private static final Pattern DNI_PATTERN = Pattern.compile("^\\d{8}$");
    
    public static boolean validarEmail(String email) {
        return StringUtils.isNotBlank(email) && EMAIL_PATTERN.matcher(email).matches();
    }
    
    public static boolean validarDNI(String dni) {
        return StringUtils.isNotBlank(dni) && DNI_PATTERN.matcher(dni).matches();
    }
    
    public static boolean validarNumeroPositivo(Double numero) {
        return numero != null && numero > 0;
    }
}
TAREA 8: Crear clase FormatoUtil
javapackage com.ventas.util;

import java.text.DecimalFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class FormatoUtil {
    
    private static final DecimalFormat FORMATO_MONEDA = new DecimalFormat("S/ #,##0.00");
    private static final DateTimeFormatter FORMATO_FECHA = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    
    public static String formatearMoneda(Double monto) {
        return monto != null ? FORMATO_MONEDA.format(monto) : "S/ 0.00";
    }
    
    public static String formatearFecha(LocalDateTime fecha) {
        return fecha != null ? fecha.format(FORMATO_FECHA) : "";
    }
}
Tiempo estimado: 2-3 días.
ENTREGABLES FINALES

9 clases DTO
4 excepciones personalizadas
1 GlobalExceptionHandler
2 clases de configuración (CORS, ModelMapper)
1 archivo application.properties
2 clases de utilidades (Validador, FormatoUtil)

COORDINACIÓN CON OTROS
Trabajas de cerca con Persona 1 (DBA) cuyos modelos mapearás a DTOs, Persona 3 (Repositories) y Persona 4 (Servicios) quienes usarán tus DTOs y utilidades, y todo el equipo que usará tus configuraciones.

PERSONA 3: DESARROLLADOR DE REPOSITORIOS
NOMBRE: _______________________________ CONTACTO: ___________________
TU ROL EN EL PROYECTO
Eres el especialista en SPRING DATA JPA. Te encargas de crear interfaces Repository que Spring Boot implementará automáticamente. Ya no necesitas escribir SQL manualmente ni crear clases DAO complejas. Spring Data JPA genera todo el código de acceso a datos por ti. Sin ti, no habría forma de consultar ni persistir información en la base de datos.
CARPETAS DONDE TRABAJARÁS

backend/src/main/java/com/ventas/repositories/ → Interfaces Repository

CONCEPTO CLAVE: SPRING DATA JPA
A diferencia del enfoque tradicional con DAOs manuales, Spring Data JPA te permite crear solo interfaces que extiendan JpaRepository. Spring Boot genera automáticamente la implementación completa con métodos como save(), findById(), findAll(), delete(), entre otros. Además, puedes crear métodos de consulta siguiendo convenciones de nombres y Spring generará el SQL automáticamente.
SEMANA 2-3: CREAR REPOSITORIES
TAREA 1: Crear ProductoRepository
javapackage com.ventas.repositories;

import com.ventas.entities.Producto;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface ProductoRepository extends JpaRepository<Producto, Long> {
    
    // Spring genera automáticamente: save(), findById(), findAll(), deleteById()
    
    // Métodos de consulta por convención de nombres
    List<Producto> findByNombreContaining(String nombre);
    List<Producto> findByCategoriaId(Long categoriaId);
    List<Producto> findByActivoTrue();
    List<Producto> findByStockLessThan(Integer stock);
    Optional<Producto> findByNombreIgnoreCase(String nombre);
    boolean existsByNombre(String nombre);
    
    // Consulta personalizada con JPQL
    @Query("SELECT p FROM Producto p WHERE p.categoria.id = :categoriaId AND p.activo = true")
    List<Producto> findProductosActivosPorCategoria(Long categoriaId);
}
Nota importante: No necesitas implementar estos métodos. Spring Data JPA los implementa automáticamente basándose en los nombres de los métodos.
TAREA 2: Crear UsuarioRepository
java@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, Long> {
    Optional<Usuario> findByUsuario(String usuario);
    Optional<Usuario> findByEmail(String email);
    List<Usuario> findByRol(TipoUsuario rol);
    List<Usuario> findByActivoTrue();
    boolean existsByUsuario(String usuario);
    boolean existsByEmail(String email);
}
TAREA 3: Crear ClienteRepository
java@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long> {
    Optional<Cliente> findByDni(String dni);
    List<Cliente> findByNombreContainingIgnoreCaseOrApellidoContainingIgnoreCase(String nombre, String apellido);
    boolean existsByDni(String dni);
    
    @Query("SELECT c FROM Cliente c WHERE CONCAT(c.nombre, ' ', c.apellido) LIKE %:nombreCompleto%")
    List<Cliente> buscarPorNombreCompleto(String nombreCompleto);
}
TAREA 4: Crear CategoriaRepository
java@Repository
public interface CategoriaRepository extends JpaRepository<Categoria, Long> {
    Optional<Categoria> findByNombre(String nombre);
    boolean existsByNombre(String nombre);
}
TAREA 5: Crear VentaRepository
java@Repository
public interface VentaRepository extends JpaRepository<Venta, Long> {
    List<Venta> findByFechaVentaBetween(LocalDateTime inicio, LocalDateTime fin);
    List<Venta> findByClienteId(Long clienteId);
    List<Venta> findByUsuarioId(Long usuarioId);
    List<Venta> findByEstado(EstadoVenta estado);
    
    @Query("SELECT SUM(v.total) FROM Venta v WHERE DATE(v.fechaVenta) = DATE(:fecha)")
    Double calcularTotalVentasDia(LocalDateTime fecha);
    
    @Query("SELECT v FROM Venta v WHERE v.fechaVenta >= :fecha ORDER BY v.fechaVenta DESC")
    List<Venta> findVentasRecientes(LocalDateTime fecha);
}
TAREA 6: Crear DetalleVentaRepository
java@Repository
public interface DetalleVentaRepository extends JpaRepository<DetalleVenta, Long> {
    List<DetalleVenta> findByVentaId(Long ventaId);
    List<DetalleVenta> findByProductoId(Long productoId);
    
    @Query("SELECT d.producto, SUM(d.cantidad) as total FROM DetalleVenta d " +
           "GROUP BY d.producto ORDER BY total DESC")
    List<Object[]> findProductosMasVendidos();
}
Tiempo estimado por repository: 1 día. Total: 4-5 días.
CONVENCIONES DE NOMBRES EN SPRING DATA JPA
Spring Data JPA entiende ciertas palabras clave en los nombres de métodos y genera el SQL correspondiente:

findBy → SELECT
countBy → COUNT
deleteBy → DELETE
existsBy → EXISTS
Containing → LIKE '%valor%'
IgnoreCase → Case insensitive
OrderBy → ORDER BY
And / Or → Operadores lógicos
LessThan / GreaterThan → Comparaciones
Between → BETWEEN

ENTREGABLES FINALES

ProductoRepository.java
UsuarioRepository.java
ClienteRepository.java
CategoriaRepository.java
VentaRepository.java
DetalleVentaRepository.java

COORDINACIÓN CON OTROS
Dependes de Persona 1 (DBA) quien crea las entidades que usarás. Te necesitan Persona 4 (Servicios) quien inyectará tus repositories en sus servicios.

PERSONA 4: DESARROLLADOR DE SERVICIOS
NOMBRE: _______________________________ CONTACTO: ___________________
TU ROL EN EL PROYECTO
Eres el CEREBRO DEL SISTEMA. Te encargas de implementar reglas de negocio, validar operaciones complejas, coordinar múltiples repositories, realizar cálculos y procesos, y aplicar lógica específica del negocio. Sin ti, el sistema solo guardaría y recuperaría datos sin inteligencia ni validaciones de negocio.
CARPETAS DONDE TRABAJARÁS

backend/src/main/java/com/ventas/services/ → Servicios de negocio

CONCEPTO CLAVE: ARQUITECTURA DE SERVICIOS EN SPRING BOOT
Los servicios en Spring Boot se anotan con @Service y utilizan inyección de dependencias con @RequiredArgsConstructor de Lombok. Ya no instancias objetos manualmente, Spring los inyecta automáticamente. Los servicios coordinan repositories, aplican validaciones, ejecutan cálculos y manejan transacciones con @Transactional.
SEMANA 4-5: CREAR SERVICIOS
TAREA 1: Crear ProductoService
javapackage com.ventas.services;

import com.ventas.dto.ProductoDTO;
import com.ventas.entities.Producto;
import com.ventas.exception.ResourceNotFoundException;
import com.ventas.exception.StockInsuficienteException;
import com.ventas.repositories.ProductoRepository;
import com.ventas.repositories.CategoriaRepository;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ProductoService {
    
    private final ProductoRepository productoRepository;
    private final CategoriaRepository categoriaRepository;
    private final ModelMapper modelMapper;
    
    @Transactional(readOnly = true)
    public List<ProductoDTO> listarTodos() {
        return productoRepository.findAll().stream()
            .map(p -> modelMapper.map(p, ProductoDTO.class))
            .collect(Collectors.toList());
    }
    
    @Transactional(readOnly = true)
    public ProductoDTO buscarPorId(Long id) {
        Producto producto = productoRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Producto", "id", id));
        return modelMapper.map(producto, ProductoDTO.class);
    }
    
    @Transactional
    public ProductoDTO guardar(ProductoDTO dto) {
        // Validaciones de negocio
        if (dto.getPrecio() == null || dto.getPrecio() <= 0) {
            throw new IllegalArgumentException("El precio debe ser mayor a 0");
        }
        
        if (dto.getStock() == null || dto.getStock() < 0) {
            throw new IllegalArgumentException("El stock no puede ser negativo");
        }
        
        // Verificar que la categoría existe
        if (!categoriaRepository.existsById(dto.getCategoriaId())) {
            throw new ResourceNotFoundException("Categoria", "id", dto.getCategoriaId());
        }
        
        Producto producto = modelMapper.map(dto, Producto.class);
        Producto guardado = productoRepository.save(producto);
        return modelMapper.map(guardado, ProductoDTO.class);
    }
    
    @Transactional
    public void reducirStock(Long productoId, Integer cantidad) {
        Producto producto = productoRepository.findById(productoId)
            .orElseThrow(() -> new ResourceNotFoundException("Producto", "id", productoId));
        
        if (producto.getStock() < cantidad) {
            throw new StockInsuficienteException(
                producto.getNombre(), 
                producto.getStock(), 
                cantidad
            );
        }
        
        producto.setStock(producto.getStock() - cantidad);
        productoRepository.save(producto);
    }
    
    @Transactional(readOnly = true)
    public List<ProductoDTO> buscarPorCategoria(Long categoriaId) {
        return productoRepository.findByCategoriaId(categoriaId).stream()
            .map(p -> modelMapper.map(p, ProductoDTO.class))
            .collect(Collectors.toList());
    }
}
TAREA 2: Crear VentaService
java@Service
@RequiredArgsConstructor
public class VentaService {
    
    private final VentaRepository ventaRepository;
    private final ProductoRepository productoRepository;
    private final DetalleVentaRepository detalleVentaRepository;
    private final ClienteRepository clienteRepository;
    private final ProductoService productoService;
    private final ModelMapper modelMapper;
    
    @Transactional
    public VentaDTO procesarVenta(VentaDTO ventaDTO, List<DetalleVentaDTO> detallesDTO) {
        // Validar que el cliente existe
        if (!clienteRepository.existsById(ventaDTO.getClienteId())) {
            throw new ResourceNotFoundException("Cliente", "id", ventaDTO.getClienteId());
        }
        
        // Validar stock de todos los productos ANTES de procesar
        for (DetalleVentaDTO detalle : detallesDTO) {
            Producto producto = productoRepository.findById(detalle.getProductoId())
                .orElseThrow(() -> new ResourceNotFoundException("Producto", "id", detalle.getProductoId()));
            
            if (producto.getStock() < detalle.getCantidad()) {
                throw new StockInsuficienteException(
                    producto.getNombre(), 
                    producto.getStock(), 
                    detalle.getCantidad()
                );
            }
        }
        
        // Calcular totales
        double subtotal = 0;
        for (DetalleVentaDTO detalle : detallesDTO) {
            Producto producto = productoRepository.findById(detalle.getProductoId()).get();
            double subtotalDetalle = detalle.getCantidad() * producto.getPrecio();
            detalle.setSubtotal(subtotalDetalle);
            subtotal += subtotalDetalle;
        }
        
        double igv = subtotal * 0.18;
        double total = subtotal + igv;
        
        // Crear la venta
        Venta venta = new Venta();
        venta.setCliente(clienteRepository.findById(ventaDTO.getClienteId()).get());
        venta.setSubtotal(subtotal);
        venta.setIgv(igv);
        venta.setTotal(total);
        venta.setEstado(EstadoVenta.COMPLETADA);
        venta.setTipoPago(ventaDTO.getTipoPago());
        
        // Guardar la venta
        Venta ventaGuardada = ventaRepository.save(venta);
        
        // Crear los detalles y reducir stock
        for (DetalleVentaDTO detalleDTO : detallesDTO) {
            DetalleVenta detalle = new DetalleVenta();
            detalle.setVenta(ventaGuardada);
            detalle.setProducto(productoRepository.findById(detalleDTO.getProductoId()).get());
            detalle.setCantidad(detalleDTO.getCantidad());
            detalle.setPrecioUnitario(detalle.getProducto().getPrecio());
            detalle.setSubtotal(detalleDTO.getSubtotal());
            
            detalleVentaRepository.save(detalle);
            
            // Reducir stock del producto
            productoService.reducirStock(detalleDTO.getProductoId(), detalleDTO.getCantidad());
        }
        
        return modelMapper.map(ventaGuardada, VentaDTO.class);
    }
    
    @Transactional(readOnly = true)
    public List<VentaDTO> listarVentasPorFecha(LocalDateTime inicio, LocalDateTime fin) {
        return ventaRepository.findByFechaVentaBetween(inicio, fin).stream()
            .map(v -> modelMapper.map(v, VentaDTO.class))
            .collect(Collectors.toList());
    }
    
    @Transactional(readOnly = true)
    public Double calcularTotalVentasDia(LocalDateTime fecha) {
        Double total = ventaRepository.calcularTotalVentasDia(fecha);
        return total != null ? total : 0.0;
    }
}
TAREA 3: Crear ClienteService
java@Service
@RequiredArgsConstructor
public class ClienteService {
    
    private final ClienteRepository clienteRepository;
    private final ModelMapper modelMapper;
    
    @Transactional(readOnly = true)
    public List<ClienteDTO> listarTodos() {
        return clienteRepository.findAll().stream()
            .map(c -> modelMapper.map(c, ClienteDTO.class))
            .collect(Collectors.toList());
    }
    
    @Transactional
    public ClienteDTO guardar(ClienteDTO dto) {
        // Validar DNI
        if (dto.getDni() == null || !dto.getDni().matches("\\d{8}")) {
            throw new IllegalArgumentException("DNI debe tener 8 dígitos");
        }
        
        // Verificar que el DNI no esté duplicado
        if (clienteRepository.existsByDni(dto.getDni())) {
            throw new DuplicateResourceException("Cliente", "DNI", dto.getDni());
        }
        
        Cliente cliente = modelMapper.map(dto, Cliente.class);
        Cliente guardado = clienteRepository.save(cliente);
        return modelMapper.map(guardado, ClienteDTO.class);
    }
    
    @Transactional(readOnly = true)
    public ClienteDTO buscarPorDni(String dni) {
        Cliente cliente = clienteRepository.findByDni(dni)
            .orElseThrow(() -> new ResourceNotFoundException("Cliente", "DNI", dni));
        return modelMapper.map(cliente, ClienteDTO.class);
    }
}
TAREA 4: Crear UsuarioService
java@Service
@RequiredArgsConstructor
public class UsuarioService {
    
    private final UsuarioRepository usuarioRepository;
    private final ModelMapper modelMapper;
    // private final PasswordEncoder passwordEncoder; // Para Spring Security
    
    @Transactional
    public UsuarioDTO registrar(UsuarioDTO dto) {
        // Validar que el usuario no exista
        if (usuarioRepository.existsByUsuario(dto.getUsuario())) {
            throw new DuplicateResourceException("Usuario", "usuario", dto.getUsuario());
        }
        
        // Validar email
        if (usuarioRepository.existsByEmail(dto.getEmail())) {
            throw new DuplicateResourceException("Usuario", "email", dto.getEmail());
        }
        
        Usuario usuario = modelMapper.map(dto, Usuario.class);
        // usuario.setPassword(passwordEncoder.encode(dto.getPassword())); // Encriptar
        
        Usuario guardado = usuarioRepository.save(usuario);
        return modelMapper.map(guardado, UsuarioDTO.class);
    }
    
    @Transactional(readOnly = true)
    public UsuarioDTO validarLogin(String usuario, String password) {
        Usuario user = usuarioRepository.findByUsuario(usuario)
            .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado"));
        
        // Aquí iría la validación del password con passwordEncoder
        if (!user.getActivo()) {
            throw new IllegalStateException("Usuario inactivo");
        }
        
        return modelMapper.map(user, UsuarioDTO.class);
    }
}
TAREA 5: Crear ReporteService
java@Service
@RequiredArgsConstructor
public class ReporteService {
    
    private final VentaRepository ventaRepository;
    private final DetalleVentaRepository detalleVentaRepository;
    
    @Transactional(readOnly = true)
    public List<VentaDiariaDTO> obtenerVentasDiarias(int dias) {
        LocalDateTime fechaInicio = LocalDateTime.now().minusDays(dias);
        List<Venta> ventas = ventaRepository.findVentasRecientes(fechaInicio);
        
        // Agrupar por fecha y sumar totales
        Map<LocalDate, Double> ventasPorDia = ventas.stream()
            .collect(Collectors.groupingBy(
                v -> v.getFechaVenta().toLocalDate(),
                Collectors.summingDouble(Venta::getTotal)
            ));
        
        return ventasPorDia.entrySet().stream()
            .map(entry -> VentaDiariaDTO.builder()
                .fecha(entry.getKey().format(DateTimeFormatter.ofPattern("dd/MM")))
                .total(entry.getValue())
                .build())
            .collect(Collectors.toList());
    }
    
    @Transactional(readOnly = true)
    public List<ProductoVendidoDTO> obtenerProductosMasVendidos(int limite) {
        List<Object[]> resultados = detalleVentaRepository.findProductosMasVendidos();
        
        return resultados.stream()
            .limit(limite)
            .map(r -> ProductoVendidoDTO.builder()
                .nombre(((Producto) r[0]).getNombre())
                .cantidad(((Number) r[1]).intValue())
                .build())
            .collect(Collectors.toList());
    }
}
Tiempo estimado: 5-6 días.
ENTREGABLES FINALES

ProductoService.java
VentaService.java
ClienteService.java
UsuarioService.java
CategoriaService.java
ReporteService.java

COORDINACIÓN CON OTROS
Dependes de Persona 3 (Repositories) cuyos repositories inyectarás, y Persona 2 (Backend) cuyas utilidades y DTOs usarás. Te necesita Persona 5 (Controladores) quien llamará a tus servicios.

PERSONA 5: DESARROLLADOR DE CONTROLADORES REST
NOMBRE: _______________________________ CONTACTO: ___________________
TU ROL EN EL PROYECTO
Eres el ARQUITECTO DE LA API REST. Te encargas de crear endpoints HTTP que el frontend consumirá mediante peticiones JSON. Ya no manejas eventos de botones ni interfaz gráfica directamente, sino que expones servicios REST que devuelven datos en formato JSON. Sin ti, el frontend no tendría forma de comunicarse con el backend.
CARPETAS DONDE TRABAJARÁS

backend/src/main/java/com/ventas/controllers/ → Controladores REST
backend/src/main/java/com/ventas/security/ → Configuración de seguridad

CONCEPTO CLAVE: ARQUITECTURA REST
Los controladores REST se anotan con @RestController y @RequestMapping. Cada método representa un endpoint HTTP (GET, POST, PUT, DELETE) que devuelve objetos que Spring Boot convierte automáticamente a JSON. No hay JSP, no hay vistas HTML en el backend, solo JSON.
SEMANA 5-6: CREAR CONTROLADORES REST
TAREA 1: Crear ProductoController
javapackage com.ventas.controllers;

import com.ventas.dto.ProductoDTO;
import com.ventas.services.ProductoService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/productos")
@RequiredArgsConstructor
public class ProductoController {
    
    private final ProductoService productoService;
    
    @GetMapping
    public ResponseEntity<List<ProductoDTO>> listarTodos() {
        return ResponseEntity.ok(productoService.listarTodos());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ProductoDTO> buscarPorId(@PathVariable Long id) {
        return ResponseEntity.ok(productoService.buscarPorId(id));
    }
    
    @PostMapping
    public ResponseEntity<ProductoDTO> crear(@RequestBody ProductoDTO dto) {
        ProductoDTO creado = productoService.guardar(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(creado);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<ProductoDTO> actualizar(
            @PathVariable Long id, 
            @RequestBody ProductoDTO dto) {
        dto.setId(id);
        return ResponseEntity.ok(productoService.guardar(dto));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> eliminar(@PathVariable Long id) {
        productoService.eliminar(id);
        return ResponseEntity.noContent().build();
    }
    
    @GetMapping("/categoria/{categoriaId}")
    public ResponseEntity<List<ProductoDTO>> listarPorCategoria(@PathVariable Long categoriaId) {
        return ResponseEntity.ok(productoService.buscarPorCategoria(categoriaId));
    }
    
    @GetMapping("/buscar")
    public ResponseEntity<List<ProductoDTO>> buscarPorNombre(@RequestParam String nombre) {
        return ResponseEntity.ok(productoService.buscarPorNombre(nombre));
    }
}
TAREA 2: Crear VentaController
java@RestController
@RequestMapping("/api/ventas")
@RequiredArgsConstructor
public class VentaController {
    
    private final VentaService ventaService;
    
    @PostMapping
    public ResponseEntity<VentaDTO> procesarVenta(@RequestBody VentaRequestDTO request) {
        VentaDTO venta = ventaService.procesarVenta(
            request.getVenta(), 
            request.getDetalles()
        );
        return ResponseEntity.status(HttpStatus.CREATED).body(venta);
    }
    
    @GetMapping
    public ResponseEntity<List<VentaDTO>> listarTodas() {
        return ResponseEntity.ok(ventaService.listarTodas());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<VentaDTO> buscarPorId(@PathVariable Long id) {
        return ResponseEntity.ok(ventaService.buscarPorId(id));
    }
    
    @GetMapping("/fecha")
    public ResponseEntity<List<VentaDTO>> listarPorFecha(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fin) {
        return ResponseEntity.ok(ventaService.listarVentasPorFecha(inicio, fin));
    }
    
    @GetMapping("/total-dia")
    public ResponseEntity<Double> obtenerTotalDia(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fecha) {
        return ResponseEntity.ok(ventaService.calcularTotalVentasDia(fecha));
    }
}
TAREA 3: Crear ClienteController
java@RestController
@RequestMapping("/api/clientes")
@RequiredArgsConstructor
public class ClienteController {
    
    private final ClienteService clienteService;
    
    @GetMapping
    public ResponseEntity<List<ClienteDTO>> listarTodos() {
        return ResponseEntity.ok(clienteService.listarTodos());
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ClienteDTO> buscarPorId(@PathVariable Long id) {
        return ResponseEntity.ok(clienteService.buscarPorId(id));
    }
    
    @PostMapping
    public ResponseEntity<ClienteDTO> crear(@RequestBody ClienteDTO dto) {
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(clienteService.guardar(dto));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<ClienteDTO> actualizar(
            @PathVariable Long id, 
            @RequestBody ClienteDTO dto) {
        dto.setId(id);
        return ResponseEntity.ok(clienteService.actualizar(dto));
    }
    
    @GetMapping("/dni/{dni}")
    public ResponseEntity<ClienteDTO> buscarPorDni(@PathVariable String dni) {
        return ResponseEntity.ok(clienteService.buscarPorDni(dni));
    }
}
TAREA 4: Crear AuthController
java@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {
    
    private final UsuarioService usuarioService;
    private final JwtTokenProvider jwtTokenProvider; // Componente para generar JWT
    
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest request) {
        UsuarioDTO usuario = usuarioService.validarLogin(
            request.getUsuario(), 
            request.getPassword()
        );
        
        String token = jwtTokenProvider.generateToken(usuario.getUsuario());
        
        LoginResponse response = LoginResponse.builder()
            .token(token)
            .tipo("Bearer")
            .id(usuario.getId())
            .usuario(usuario.getUsuario())
            .nombreCompleto(usuario.getNombre() + " " + usuario.getApellido())
            .rol(usuario.getRol().name())
            .build();
        
        return ResponseEntity.ok(response);
    }
    
    @PostMapping("/register")
    public ResponseEntity<UsuarioDTO> register(@RequestBody UsuarioDTO dto) {
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(usuarioService.registrar(dto));
    }
}
TAREA 5: Crear ReporteController
java@RestController
@RequestMapping("/api/reportes")
@RequiredArgsConstructor
public class ReporteController {
    
    private final ReporteService reporteService;
    
    @GetMapping("/ventas-diarias")
    public ResponseEntity<List<VentaDiariaDTO>> obtenerVentasDiarias(
            @RequestParam(required = false, defaultValue = "30") int dias) {
        return ResponseEntity.ok(reporteService.obtenerVentasDiarias(dias));
    }
    
    @GetMapping("/productos-mas-vendidos")
    public ResponseEntity<List<ProductoVendidoDTO>> obtenerProductosMasVendidos(
            @RequestParam(required = false, defaultValue = "10") int limite) {
        return ResponseEntity.ok(reporteService.obtenerProductosMasVendidos(limite));
    }
    
    @GetMapping("/ventas-por-categoria")
    public ResponseEntity<List<VentaCategoriaDTO>> obtenerVentasPorCategoria() {
        return ResponseEntity.ok(reporteService.obtenerVentasPorCategoria());
    }
}
SEMANA 6: CONFIGURAR SPRING SECURITY CON JWT
TAREA 6: Crear JwtTokenProvider
javapackage com.ventas.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;

@Component
public class JwtTokenProvider {
    
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    @Value("${jwt.expiration}")
    private long jwtExpiration;
    
    public String generateToken(String usuario) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);
        
        Key key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
        
        return Jwts.builder()
            .setSubject(usuario)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(key, SignatureAlgorithm.HS512)
            .compact();
    }
    
    public String getUsernameFromToken(String token) {
        Key key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
        Claims claims = Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Key key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
TAREA 7: Crear SecurityConfig
javapackage com.ventas.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests()
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/**").authenticated()
            .and()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
        
        return http.build();
    }
}
Tiempo estimado: 6-7 días.
ENTREGABLES FINALES

ProductoController.java
VentaController.java
ClienteController.java
AuthController.java
ReporteController.java
CategoriaController.java
JwtTokenProvider.java
SecurityConfig.java

COORDINACIÓN CON OTROS
Dependes de Persona 4 (Servicios) cuyos servicios inyectarás en tus controladores. Trabajas de cerca con Persona 7 (Frontend) quien consumirá tus endpoints REST.